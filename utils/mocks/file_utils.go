// Code generated by mockery v2.30.1. DO NOT EDIT.

package mocks

import (
	pflag "github.com/spf13/pflag"
	mock "github.com/stretchr/testify/mock"

	types "razor/core/types"
)

// FileUtils is an autogenerated mock type for the FileUtils type
type FileUtils struct {
	mock.Mock
}

// AssignLogFile provides a mock function with given fields: flagSet, configurations
func (_m *FileUtils) AssignLogFile(flagSet *pflag.FlagSet, configurations types.Configurations) {
	_m.Called(flagSet, configurations)
}

// ReadFromCommitJsonFile provides a mock function with given fields: filePath
func (_m *FileUtils) ReadFromCommitJsonFile(filePath string) (types.CommitFileData, error) {
	ret := _m.Called(filePath)

	var r0 types.CommitFileData
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (types.CommitFileData, error)); ok {
		return rf(filePath)
	}
	if rf, ok := ret.Get(0).(func(string) types.CommitFileData); ok {
		r0 = rf(filePath)
	} else {
		r0 = ret.Get(0).(types.CommitFileData)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(filePath)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReadFromDisputeJsonFile provides a mock function with given fields: filePath
func (_m *FileUtils) ReadFromDisputeJsonFile(filePath string) (types.DisputeFileData, error) {
	ret := _m.Called(filePath)

	var r0 types.DisputeFileData
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (types.DisputeFileData, error)); ok {
		return rf(filePath)
	}
	if rf, ok := ret.Get(0).(func(string) types.DisputeFileData); ok {
		r0 = rf(filePath)
	} else {
		r0 = ret.Get(0).(types.DisputeFileData)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(filePath)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReadFromProposeJsonFile provides a mock function with given fields: filePath
func (_m *FileUtils) ReadFromProposeJsonFile(filePath string) (types.ProposeFileData, error) {
	ret := _m.Called(filePath)

	var r0 types.ProposeFileData
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (types.ProposeFileData, error)); ok {
		return rf(filePath)
	}
	if rf, ok := ret.Get(0).(func(string) types.ProposeFileData); ok {
		r0 = rf(filePath)
	} else {
		r0 = ret.Get(0).(types.ProposeFileData)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(filePath)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SaveDataToCommitJsonFile provides a mock function with given fields: filePath, epoch, commitData, commitment
func (_m *FileUtils) SaveDataToCommitJsonFile(filePath string, epoch uint32, commitData types.CommitData, commitment [32]byte) error {
	ret := _m.Called(filePath, epoch, commitData, commitment)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, uint32, types.CommitData, [32]byte) error); ok {
		r0 = rf(filePath, epoch, commitData, commitment)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SaveDataToDisputeJsonFile provides a mock function with given fields: filePath, bountyIdQueue
func (_m *FileUtils) SaveDataToDisputeJsonFile(filePath string, bountyIdQueue []uint32) error {
	ret := _m.Called(filePath, bountyIdQueue)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, []uint32) error); ok {
		r0 = rf(filePath, bountyIdQueue)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SaveDataToProposeJsonFile provides a mock function with given fields: filePath, proposeData
func (_m *FileUtils) SaveDataToProposeJsonFile(filePath string, proposeData types.ProposeFileData) error {
	ret := _m.Called(filePath, proposeData)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, types.ProposeFileData) error); ok {
		r0 = rf(filePath, proposeData)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewFileUtils creates a new instance of FileUtils. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewFileUtils(t interface {
	mock.TestingT
	Cleanup(func())
}) *FileUtils {
	mock := &FileUtils{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
